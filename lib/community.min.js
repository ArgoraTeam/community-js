!function(t){"function"==typeof define&&define.amd?define(t):t()}((function(){"use strict";Object.defineProperty(exports,"__esModule",{value:!0});const t=require("tslib"),e=t.__importDefault(require("axios")),a=require("smartweave"),n=t.__importDefault(require("redstone-api")),s=t.__importDefault(require("./utils"));exports.default=class{cacheServer="https://cache.community.xyz/";contractSrc="ngMml4jmlxu0umpiQCsHgPX2pb_Yz6YDB8f7G6j-tpI";mainContract="mzvUgNc8YFk0w5K5H7c8pyT-FC5Y_ba0r7_8766Kx74";txFeeUsd=.5;createFeeUsd=3;createFee=.83;txFee=.21;arweave;wallet;walletAddress;dummyWallet;isWalletConnect=!1;communityContract="";state;firstCall=!0;cacheRefreshInterval=12e4;stateCallInProgress=!1;warnAfter=864e5;updatedFees=!1;constructor(t,e,a=12e4){this.arweave=t,e&&(this.wallet=e,t.wallets.jwkToAddress(e).then((t=>this.walletAddress=t)).catch(console.log)),a&&(this.cacheRefreshInterval=a),this.getFees(),this.events()}async getMainContractId(){return this.mainContract}async getContractSourceId(){return this.contractSrc}async getCommunityContract(){return this.communityContract}async getState(t=!0){if(!this.communityContract.length)throw new Error("No community set. Use setCommunityTx to get your current state.");return this.firstCall?(this.firstCall=!1,this.update(!0)):t&&this.state?this.state:this.update(!1)}async setWallet(t){return this.wallet=t,this.walletAddress=await this.arweave.wallets.jwkToAddress(this.wallet),this.walletAddress}async setState(t,e,a,n=50,r=50,i=2e3,o=720,c=1e4,l={},u=[],h={},m=[]){if(await this.checkWallet(),t||(t=""),e||(e=""),a||(a={}),n||(n=0),r||(r=0),i||(i=0),o||(o=0),c||(c=0),l||(l={}),u||(u=[]),h||(h={}),m||(m=[]),t=t.trim(),e=e.trim(),a=s.default.trimObj(a),n=+n,r=+r,i=+i,o=+o,c=+c,l=s.default.trimObj(l),u=s.default.trimObj(u),h=s.default.trimObj(h),t.length<3)throw new Error("Community Name must be at least 3 characters.");if(e.length<3)throw new Error("Ticker must be at least 3 characters.");if(!Object.keys(a).length)throw new Error("At least one account need to be specified.");for(const t in a)if(isNaN(a[t])||!Number.isInteger(a[t])||a[t]<0)throw new Error("Address balances must be a positive integer.");if(isNaN(n)||n<1||n>99||!Number.isInteger(n))throw new Error("Quorum must be an integer between 1-99.");if(n/=100,isNaN(r)||r<1||r>99||!Number.isInteger(r))throw new Error("Support must be an integer between 1-99.");if(r/=100,isNaN(i)||!Number.isInteger(i)||i<1)throw new Error("Vote Length must be a positive integer.");if(isNaN(o)||o<1||!Number.isInteger(o))throw new Error("Lock Min Length must be a positive integer.");if(isNaN(c)||c<o||!Number.isInteger(c))throw new Error("Lock Max Length must be a positive integer, greater than lockMinLength.");if(Object.keys(l).length)for(const t of Object.keys(l))for(const e in l[t])if(isNaN(l[t][e].balance)||!Number.isInteger(l[t][e].balance)||l[t][e].balance<0)throw new Error("Vault balance must be a positive integer.");const w=[["quorum",n],["support",r],["voteLength",i],["lockMinLength",o],["lockMaxLength",c]];for(let t=0,e=m.length;t<e;t++){const e=m[t];"string"==typeof e[0]&&void 0!==e[1]&&w.push(e)}return this.state={name:t,ticker:e,balances:a,vault:l,votes:u,roles:h,settings:new Map(w)},this.state}async setContractSourceId(t){return!!s.default.isTxId(t)&&(this.contractSrc=t,!0)}async create(t=[]){const{target:e,winstonQty:n}=await this.chargeFee(this.createFee),s=this.state;s.settings=Array.from(this.state.settings),t=[...await this.cleanTags(t),{name:"Action",value:"CreateCommunity"},{name:"Message",value:`Created Community ${this.state.name}, ticker: ${this.state.ticker}.`},{name:"Service",value:"CommunityXYZ"}];const r=await a.createContractFromTx(this.arweave,this.wallet,this.contractSrc,JSON.stringify(s),t,e,n);return this.communityContract=r,r}async getCreateCost(t=!1,e){if(!this.updatedFees)return await new Promise((t=>setTimeout((()=>t(!0)),100))),this.getCreateCost(t,e);const a=this.arweave.ar.arToWinston(this.createFee.toString());return t?this.arweave.ar.winstonToAr(a,e):a}async getActionCost(t=!1,e){if(!this.updatedFees)return await new Promise((t=>setTimeout((()=>t(!0)),100))),this.getActionCost(t,e);const a=this.arweave.ar.arToWinston(this.txFee.toString());return t?this.arweave.ar.winstonToAr(a,e):a}async setCommunityTx(t){this.state=null,this.communityContract=t;try{await this.getState(!1)}catch(t){return this.state=null,this.communityContract=null,console.log(t),!1}return!0}async get(t={function:"balance"}){return this.wallet||this.dummyWallet||(this.dummyWallet=await this.arweave.wallets.generate()),a.interactRead(this.arweave,this.wallet||this.dummyWallet,this.communityContract,t)}async getBalance(t=this.walletAddress){return(await this.get({function:"balance",target:t})).balance}async getUnlockedBalance(t=this.walletAddress){return(await this.get({function:"unlockedBalance",target:t})).balance}async getVaultBalance(t=this.walletAddress){return(await this.get({function:"vaultBalance",target:t})).balance}async getRole(t=this.walletAddress){return(await this.get({function:"role",target:t})).role}async selectWeightedHolder(t=this.state.balances,e=this.state.vault){if(!this.state)throw new Error("Need to initilate the state and worker.");let a=0;for(const e of Object.keys(t))a+=t[e];for(const n of Object.keys(e)){if(!e[n].length)continue;const s=e[n].map((t=>t.balance)).reduce(((t,e)=>t+e),0);a+=s,n in t?t[n]+=s:t[n]=s}const n={};for(const e of Object.keys(t))n[e]=t[e]/a;let s=0;const r=Math.random();for(const t of Object.keys(n))if(s+=n[t],r<=s&&n[t]>0)return t;return null}async getFees(){try{const t=await n.default.getPrice("AR"),e=t.timestamp,a=t.value;if(e&&a){(new Date).getTime()-e>this.warnAfter&&console.warn("Price hasn't been updated over a day ago!"),this.createFee=+(this.createFeeUsd/a).toFixed(5),this.txFee=+(this.txFeeUsd/a).toFixed(5)}}catch(t){console.log(t),console.warn("Was not able to update the fees, please try again later")}return this.updatedFees=!0,{createFee:this.createFee,txFee:this.txFee}}async transfer(t,e,a=[]){return a=[...await this.cleanTags(a),{name:"Action",value:"transfer"},{name:"Message",value:`Transfer to ${t} of ${s.default.formatNumber(e)}.`},{name:"Community-ID",value:this.communityContract},{name:"Service",value:"CommunityXYZ"}],this.interact({function:"transfer",target:t,qty:e},a)}async transferLocked(t,e,a,n=[]){return n=[...await this.cleanTags(n),{name:"Action",value:"transferLocked"},{name:"Message",value:`Transfer locked to ${t} of ${s.default.formatNumber(e)} for ${s.default.formatNumber(a)} blocks.`},{name:"Community-ID",value:this.communityContract},{name:"Service",value:"CommunityXYZ"}],this.interact({function:"transferLocked",target:t,qty:e,lockLength:a},n)}async lockBalance(t,e,a=[]){return a=[...await this.cleanTags(a),{name:"Action",value:"lock"},{name:"Message",value:`Locked ${s.default.formatNumber(t)} for ${s.default.formatNumber(e)} blocks (${s.default.formatBlocks(e)}).`},{name:"Community-ID",value:this.communityContract},{name:"Service",value:"CommunityXYZ"}],this.interact({function:"lock",qty:t,lockLength:e},a)}async unlockVault(t=[]){return t=[...await this.cleanTags(t),{name:"Action",value:"unlock"},{name:"Message",value:"Unlocked vaults."},{name:"Community-ID",value:this.communityContract},{name:"Service",value:"CommunityXYZ"}],this.interact({function:"unlock"},t)}async increaseVault(t,e,a=[]){return a=[...await this.cleanTags(a),{name:"Action",value:"increase"},{name:"Message",value:`Increased vault ID ${t} for ${e} blocks (${s.default.formatBlocks(e)}).`},{name:"Community-ID",value:this.communityContract},{name:"Service",value:"CommunityXYZ"}],this.interact({function:"increaseVault",id:t,lockLength:e},a)}async proposeVote(t,e=[]){const a=JSON.parse(JSON.stringify(t));if(console.log(a),"set"===a.type){if("quorum"!==a.key&&"support"!==a.key&&"lockMinLength"!==a.key&&"lockMaxLength"!==a.key||(a.value=+a.value),"quorum"===a.key||"support"===a.key)if(a.value>0&&a.value<100)a.value=a.value/100;else if(a.value<=0||a.value>=100)throw new Error("Invalid value.");if("lockMinLength"===a.key&&(a.value<1||a.value>this.state.settings.get("lockMaxLength")))throw new Error("Invalid minimum lock length.");if("lockMaxLength"===a.key&&(a.value<1||a.value<this.state.settings.get("lockMinLength")))throw new Error("Invalid maximum lock length.")}const n={...a,function:"propose"};return e=[...await this.cleanTags(e),{name:"Action",value:"propose"},{name:"Message",value:`Proposed ${"indicative"===a.type||"other"===a.key?"an":"a"} ${a.key||a.type} vote, value: ${a.value}.`},{name:"Community-ID",value:this.communityContract},{name:"Service",value:"CommunityXYZ"}],this.interact(n,e)}async vote(t,e,a=[]){return a=[...await this.cleanTags(a),{name:"Action",value:"vote"},{name:"Message",value:`Voted on vote ID ${t}: ${e}.`},{name:"Community-ID",value:this.communityContract},{name:"Service",value:"CommunityXYZ"}],this.interact({function:"vote",id:t,cast:e},a)}async finalize(t,e=[]){return e=[...await this.cleanTags(e),{name:"Action",value:"finalize"},{name:"Message",value:"Finalize completed votes."},{name:"Community-ID",value:this.communityContract},{name:"Service",value:"CommunityXYZ"}],this.interact({function:"finalize",id:t},e)}async chargeFee(t=this.txFee){if(+await this.arweave.wallets.getBalance(this.walletAddress)<+t)throw new Error("Not enough balance.");let n;try{n=(await e.default(`${this.cacheServer}contract/${this.mainContract}`)).data}catch(t){n=await a.readContract(this.arweave,this.mainContract)}const s=await this.selectWeightedHolder(n.balances,n.vault);return s===this.walletAddress?{target:"",winstonQty:"0"}:{target:s,winstonQty:this.arweave.ar.arToWinston(t.toString())}}async checkWallet(){if(!this.wallet&&!this.isWalletConnect)throw new Error("You first need to set the user wallet, you can do this while on new Community(..., wallet) or using setWallet(wallet).")}async cleanTags(t){if(!t||!t.length)return[];const e=["action","message","community-id","service","type"],a=[];for(const n of t)n.name&&n.value&&(e.includes(n.name.toLowerCase())||a.push({name:n.name.toString(),value:n.value.toString()}));return a}async update(t=!1){if(!this.communityContract.length)return void setTimeout((()=>this.update()),this.cacheRefreshInterval);if(this.stateCallInProgress){const t=async()=>this.stateCallInProgress?new Promise((e=>setTimeout((()=>e(t())),1e3))):this.state;return t()}let n;this.stateCallInProgress=!0;try{n=(await e.default(`${this.cacheServer}contract/${this.communityContract}`)).data}catch(t){n=await a.readContract(this.arweave,this.communityContract)}return n.settings=new Map(n.settings),this.state=n,this.stateCallInProgress=!1,t&&setTimeout((()=>this.update(!0)),this.cacheRefreshInterval),this.state}async interact(t,e,n=this.txFee){const{target:s,winstonQty:r}=await this.chargeFee(n);e.push({name:"Type",value:"ArweaveActivity"});const i=await a.interactWriteDryRun(this.arweave,this.wallet||"use_wallet",this.communityContract,t,e,s,r);if("error"===i.type)throw new Error(i.result);return a.interactWrite(this.arweave,this.wallet||"use_wallet",this.communityContract,t,e,s,r)}events(){const t="undefined"!=typeof window?window:{removeEventListener:t=>{},addEventListener:(t,e)=>{}};async function e(){this.walletAddress=await this.arweave.wallets.getAddress(),this.isWalletConnect=!0}async function a(t){this.walletAddress=await t.detail.address,this.isWalletConnect=!0}t.removeEventListener("arweaveWalletLoaded",(()=>e())),t.removeEventListener("walletSwitch",(t=>a(t))),t.addEventListener("arweaveWalletLoaded",(()=>e())),t.addEventListener("walletSwitch",(t=>a(t)))}}}));
