{"version":3,"file":"community.min.js","sources":["../src/community.ts"],"sourcesContent":["import Arweave from 'arweave';\nimport axios from 'axios';\nimport { JWKInterface } from 'arweave/node/lib/wallet';\nimport { readContract, interactWriteDryRun, interactWrite, createContractFromTx, interactRead } from 'smartweave';\nimport redstone from 'redstone-api';\nimport {\n  BalancesInterface,\n  VaultInterface,\n  VoteInterface,\n  RoleInterface,\n  StateInterface,\n  InputInterface,\n  ResultInterface,\n  TagInterface,\n} from './faces';\nimport Utils from './utils';\n\nexport default class Community {\n  private readonly cacheServer: string = 'https://cache.community.xyz/';\n  private contractSrc: string = 'ngMml4jmlxu0umpiQCsHgPX2pb_Yz6YDB8f7G6j-tpI';\n  private readonly mainContract: string = 'mzvUgNc8YFk0w5K5H7c8pyT-FC5Y_ba0r7_8766Kx74';\n  private readonly txFeeUsd: number = 0.5;\n  private readonly createFeeUsd: number = 3;\n\n  private createFee: number = 0.83;\n  private txFee: number = 0.21;\n\n  private arweave: Arweave;\n  private wallet!: JWKInterface;\n  private walletAddress!: string;\n  private dummyWallet: JWKInterface;\n  private isWalletConnect: boolean = false;\n\n  // Community specific variables\n  private communityContract = '';\n  private state!: StateInterface;\n  private firstCall: boolean = true;\n  private cacheRefreshInterval: number = 1000 * 60 * 2; // 2 minutes\n  private stateCallInProgress: boolean = false;\n\n  private readonly warnAfter: number = 60 * 60 * 24 * 1000; // 24 hours\n  private updatedFees: boolean = false;\n\n  /**\n   * Before interacting with Community you need to have at least Arweave initialized.\n   * @param arweave - Arweave instance\n   * @param wallet - JWK wallet file data\n   * @param cacheRefreshInterval - Refresh interval in milliseconds for the cached state\n   */\n  constructor(arweave: Arweave, wallet?: JWKInterface, cacheRefreshInterval = 1000 * 60 * 2) {\n    this.arweave = arweave;\n\n    if (wallet) {\n      this.wallet = wallet;\n      arweave.wallets\n        .jwkToAddress(wallet)\n        .then((addy) => (this.walletAddress = addy))\n        .catch(console.log);\n    }\n\n    if (cacheRefreshInterval) {\n      this.cacheRefreshInterval = cacheRefreshInterval;\n    }\n\n    this.getFees();\n    this.events();\n  }\n\n  /**\n   * Get the Main Community contract ID\n   * @returns {Promise<string>} The main contract ID.\n   */\n  public async getMainContractId(): Promise<string> {\n    return this.mainContract;\n  }\n\n  /**\n   * Get the contract source txid used for new PSCs.\n   * @returns {Promise<string>} The contract source ID.\n   */\n  public async getContractSourceId(): Promise<string> {\n    return this.contractSrc;\n  }\n\n  /**\n   * Get the current Community contract ID\n   */\n  public async getCommunityContract(): Promise<string> {\n    return this.communityContract;\n  }\n\n  /**\n   * Get the current Community state.\n   * @param cached - Wether to return the cached version or reload\n   * @returns - The current state and sync afterwards if needed.\n   */\n  public async getState(cached = true): Promise<StateInterface> {\n    if (!this.communityContract.length) {\n      throw new Error('No community set. Use setCommunityTx to get your current state.');\n    }\n\n    if (this.firstCall) {\n      this.firstCall = false;\n      return this.update(true);\n    }\n\n    if (!cached || !this.state) {\n      return this.update(false);\n    }\n\n    return this.state;\n  }\n\n  /**\n   * Set the user wallet data.\n   * @param wallet - JWK wallet file data\n   * @returns The wallet address\n   */\n  public async setWallet(wallet: JWKInterface): Promise<string> {\n    this.wallet = wallet;\n    this.walletAddress = await this.arweave.wallets.jwkToAddress(this.wallet);\n\n    return this.walletAddress;\n  }\n\n  /**\n   * Set the states for a new Community using the Community contract.\n   * @param name - The Community name\n   * @param ticker - Currency ticker, ex: TICK\n   * @param balances - an object of wallet addresses and their token balances\n   * @param quorum - % of votes weight, for a proposal to be valid\n   * @param support = % of votes as \"yes\", for a vote to be valid\n   * @param voteLength - For how long (in blocks) should the vote be active\n   * @param lockMinLength - What is the minimum lock time (in blocks)\n   * @param lockMaxLength - What is the maximum lock time (in blocks)\n   * @param vault - Vault object, optional\n   * @param votes - Votes, optional\n   * @param roles - Roles, optional\n   * @param extraSettings - Any custom extra settings can be sent here. @since v1.1.0\n   *\n   * @returns - The created state\n   */\n  public async setState(\n    name: string,\n    ticker: string,\n    balances: BalancesInterface,\n    quorum: number = 50,\n    support: number = 50,\n    voteLength: number = 2000,\n    lockMinLength: number = 720,\n    lockMaxLength: number = 10000,\n    vault: VaultInterface = {},\n    votes: VoteInterface[] = [],\n    roles: RoleInterface = {},\n    extraSettings: [string, any][] = [],\n  ): Promise<StateInterface> {\n    // Make sure the wallet exists.\n    await this.checkWallet();\n\n    // Make sure data isn't null\n    if (!name) {\n      name = '';\n    }\n    if (!ticker) {\n      ticker = '';\n    }\n    if (!balances) {\n      balances = {};\n    }\n    if (!quorum) {\n      quorum = 0;\n    }\n    if (!support) {\n      support = 0;\n    }\n    if (!voteLength) {\n      voteLength = 0;\n    }\n    if (!lockMinLength) {\n      lockMinLength = 0;\n    }\n    if (!lockMaxLength) {\n      lockMaxLength = 0;\n    }\n    if (!vault) {\n      vault = {};\n    }\n    if (!votes) {\n      votes = [];\n    }\n    if (!roles) {\n      roles = {};\n    }\n    if (!extraSettings) {\n      extraSettings = [];\n    }\n\n    // Clean data\n    name = name.trim();\n    ticker = ticker.trim();\n    balances = Utils.trimObj(balances);\n    quorum = +quorum;\n    support = +support;\n    voteLength = +voteLength;\n    lockMinLength = +lockMinLength;\n    lockMaxLength = +lockMaxLength;\n    vault = Utils.trimObj(vault);\n    votes = Utils.trimObj(votes);\n    roles = Utils.trimObj(roles);\n\n    // Validations\n    if (name.length < 3) {\n      throw new Error('Community Name must be at least 3 characters.');\n    }\n    if (ticker.length < 3) {\n      throw new Error('Ticker must be at least 3 characters.');\n    }\n    if (!Object.keys(balances).length) {\n      throw new Error('At least one account need to be specified.');\n    }\n    for (const bal in balances) {\n      if (isNaN(balances[bal]) || !Number.isInteger(balances[bal]) || balances[bal] < 0) {\n        throw new Error('Address balances must be a positive integer.');\n      }\n    }\n    if (isNaN(quorum) || quorum < 1 || quorum > 99 || !Number.isInteger(quorum)) {\n      throw new Error('Quorum must be an integer between 1-99.');\n    }\n    quorum = quorum / 100;\n    if (isNaN(support) || support < 1 || support > 99 || !Number.isInteger(support)) {\n      throw new Error('Support must be an integer between 1-99.');\n    }\n    support = support / 100;\n    if (isNaN(voteLength) || !Number.isInteger(voteLength) || voteLength < 1) {\n      throw new Error('Vote Length must be a positive integer.');\n    }\n    if (isNaN(lockMinLength) || lockMinLength < 1 || !Number.isInteger(lockMinLength)) {\n      throw new Error('Lock Min Length must be a positive integer.');\n    }\n    if (isNaN(lockMaxLength) || lockMaxLength < lockMinLength || !Number.isInteger(lockMaxLength)) {\n      throw new Error('Lock Max Length must be a positive integer, greater than lockMinLength.');\n    }\n    if (Object.keys(vault).length) {\n      for (const key of Object.keys(vault)) {\n        for (const k in vault[key]) {\n          if (isNaN(vault[key][k].balance) || !Number.isInteger(vault[key][k].balance) || vault[key][k].balance < 0) {\n            throw new Error('Vault balance must be a positive integer.');\n          }\n        }\n      }\n    }\n\n    const settings: [string, any][] = [\n      ['quorum', quorum],\n      ['support', support],\n      ['voteLength', voteLength],\n      ['lockMinLength', lockMinLength],\n      ['lockMaxLength', lockMaxLength],\n    ];\n\n    for (let i = 0, j = extraSettings.length; i < j; i++) {\n      const s = extraSettings[i];\n      if (typeof s[0] === 'string' && typeof s[1] !== 'undefined') {\n        settings.push(s);\n      }\n    }\n\n    // Set the state\n    this.state = {\n      name,\n      ticker,\n      balances,\n      vault,\n      votes,\n      roles,\n      settings: new Map(settings),\n    };\n\n    return this.state;\n  }\n\n  /**\n   * Update the used contract source transaction ID.\n   * @param id New contract source ID.\n   * @returns boolean that validates if the update was done.\n   */\n  public async setContractSourceId(id: string): Promise<boolean> {\n    if (!Utils.isTxId(id)) {\n      return false;\n    }\n    this.contractSrc = id;\n    return true;\n  }\n\n  /**\n   * Create a new Community with the current, previously saved (with `setState`) state.\n   * @param tags - optional: tags to be added to this transaction\n   * @returns The created community transaction ID.\n   */\n  public async create(tags: TagInterface[] = []): Promise<string> {\n    // Create the new Community.\n    const { target, winstonQty } = await this.chargeFee(this.createFee);\n\n    const toSubmit: any = this.state;\n    toSubmit.settings = Array.from(this.state.settings);\n\n    tags = [\n      ...(await this.cleanTags(tags)),\n      ...[\n        { name: 'Action', value: 'CreateCommunity' },\n        { name: 'Message', value: `Created Community ${this.state.name}, ticker: ${this.state.ticker}.` },\n        { name: 'Service', value: 'CommunityXYZ' },\n      ],\n    ];\n\n    const communityID = await createContractFromTx(\n      this.arweave,\n      this.wallet,\n      this.contractSrc,\n      JSON.stringify(toSubmit),\n      tags,\n      target,\n      winstonQty,\n    );\n    this.communityContract = communityID;\n    return communityID;\n  }\n\n  /**\n   * Get the current create cost of a community.\n   * @param inAr - Return in winston or AR\n   * @param options - If return inAr is set to true, these options are used to format the returned AR value.\n   */\n  public async getCreateCost(\n    inAr = false,\n    options?: { formatted: boolean; decimals: number; trim: boolean },\n  ): Promise<string> {\n    if (!this.updatedFees) {\n      await new Promise((resolve) => setTimeout(() => resolve(true), 100));\n      return this.getCreateCost(inAr, options);\n    }\n\n    const res = this.arweave.ar.arToWinston(this.createFee.toString());\n    if (inAr) {\n      return this.arweave.ar.winstonToAr(res, options);\n    }\n\n    return res;\n  }\n\n  /**\n   * Get the current action (post interaction) cost of a community.\n   * @param inAr - Return in winston or AR\n   * @param options - If return inAr is set to true, these options are used to format the returned AR value.\n   */\n  public async getActionCost(\n    inAr = false,\n    options?: { formatted: boolean; decimals: number; trim: boolean },\n  ): Promise<string> {\n    if (!this.updatedFees) {\n      await new Promise((resolve) => setTimeout(() => resolve(true), 100));\n      return this.getActionCost(inAr, options);\n    }\n\n    const res = this.arweave.ar.arToWinston(this.txFee.toString());\n    if (inAr) {\n      return this.arweave.ar.winstonToAr(res, options);\n    }\n\n    return res;\n  }\n\n  /**\n   * Set the Community interactions to this transaction ID.\n   * @param txId Community's Transaction ID\n   * @returns boolean - True if successful, false if error.\n   */\n  public async setCommunityTx(txId: string): Promise<boolean> {\n    // reset state\n    this.state = null;\n    this.communityContract = txId;\n\n    try {\n      await this.getState(false);\n    } catch (e) {\n      this.state = null;\n      this.communityContract = null;\n      console.log(e);\n      return false;\n    }\n\n    return true;\n  }\n\n  /**\n   * Do a GET call to any function on the contract.\n   * @param params - InputInterface\n   * @returns ResultInterface\n   */\n  public async get(params: InputInterface = { function: 'balance' }): Promise<ResultInterface> {\n    if (!this.wallet && !this.dummyWallet) {\n      this.dummyWallet = await this.arweave.wallets.generate();\n    }\n\n    return interactRead(this.arweave, this.wallet || this.dummyWallet, this.communityContract, params);\n  }\n\n  /**\n   * Get the target or current wallet token balance\n   * @param target The target wallet address\n   * @returns Current target token balance\n   */\n  public async getBalance(target: string = this.walletAddress): Promise<number> {\n    const res = await this.get({ function: 'balance', target });\n    return res.balance;\n  }\n\n  /**\n   * Get the target or current wallet unlocked token balance\n   * @param target The target wallet address\n   * @returns Current target token balance\n   */\n  public async getUnlockedBalance(target: string = this.walletAddress): Promise<number> {\n    const res = await this.get({ function: 'unlockedBalance', target });\n    return res.balance;\n  }\n\n  /**\n   * Get the target or current wallet vault balance\n   * @param target The target wallet address\n   * @returns Current target token balance\n   */\n  public async getVaultBalance(target: string = this.walletAddress): Promise<number> {\n    const res = await this.get({ function: 'vaultBalance', target });\n    return res.balance;\n  }\n\n  /**\n   * Get the target or current wallet role\n   * @param target The target wallet address\n   * @returns Current target role\n   */\n  public async getRole(target: string = this.walletAddress): Promise<string> {\n    const res = await this.get({ function: 'role', target });\n    return res.role;\n  }\n\n  /**\n   * Select one of your community holders based on their weighted total balance.\n   * @param balances  - State balances, optional.\n   * @param vault - State vault, optional.\n   */\n  public async selectWeightedHolder(\n    balances: BalancesInterface = this.state.balances,\n    vault: VaultInterface = this.state.vault,\n  ) {\n    if (!this.state) {\n      throw new Error('Need to initilate the state and worker.');\n    }\n\n    let totalTokens = 0;\n    for (const addy of Object.keys(balances)) {\n      totalTokens += balances[addy];\n    }\n    for (const addy of Object.keys(vault)) {\n      if (!vault[addy].length) continue;\n      const vaultBalance = vault[addy].map((a) => a.balance).reduce((a, b) => a + b, 0);\n      totalTokens += vaultBalance;\n      if (addy in balances) {\n        balances[addy] += vaultBalance;\n      } else {\n        balances[addy] = vaultBalance;\n      }\n    }\n\n    const weighted: BalancesInterface = {};\n    for (const addy of Object.keys(balances)) {\n      weighted[addy] = balances[addy] / totalTokens;\n    }\n\n    let sum = 0;\n    const r = Math.random();\n    for (const addy of Object.keys(weighted)) {\n      sum += weighted[addy];\n      if (r <= sum && weighted[addy] > 0) {\n        return addy;\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Get the current fee charged for actions on Community.\n   * @return {object} - The txFee and the createFee, both are numbers.\n   */\n  public async getFees(): Promise<{ txFee: number; createFee: number }> {\n    try {\n      const price = await redstone.getPrice('AR');\n\n      const createdAt = price.timestamp;\n      const arPrice = price.value;\n\n      if (createdAt && arPrice) {\n        const deployTime = new Date().getTime() - createdAt;\n        if (deployTime > this.warnAfter) {\n          console.warn(\"Price hasn't been updated over a day ago!\");\n        }\n\n        this.createFee = +(this.createFeeUsd / arPrice).toFixed(5);\n        this.txFee = +(this.txFeeUsd / arPrice).toFixed(5);\n      }\n    } catch (e) {\n      console.log(e);\n      console.warn('Was not able to update the fees, please try again later');\n    }\n\n    this.updatedFees = true;\n    return {\n      createFee: this.createFee,\n      txFee: this.txFee,\n    };\n  }\n\n  // Setters\n\n  /**\n   * Transfer token balances to another account.\n   * @param target - Target Wallet Address\n   * @param qty - Amount of the token to send\n   * @param tags - optional: tags to be added to this transaction\n   * @returns The transaction ID for this action\n   */\n  public async transfer(target: string, qty: number, tags: TagInterface[] = []): Promise<string> {\n    tags = [\n      ...(await this.cleanTags(tags)),\n      ...[\n        { name: 'Action', value: 'transfer' },\n        { name: 'Message', value: `Transfer to ${target} of ${Utils.formatNumber(qty)}.` },\n        { name: 'Community-ID', value: this.communityContract },\n        { name: 'Service', value: 'CommunityXYZ' },\n      ],\n    ];\n\n    return this.interact({ function: 'transfer', target, qty }, tags);\n  }\n\n  /**\n   * Transfer tokens to an account's vault.\n   * @param target - Target Wallet Address\n   * @param qty - Amount of the token to send\n   * @param lockLength - For how many blocks to lock the tokens\n   * @param tags - optional: tags to be added to this transaction\n   * @returns The transaction ID for this action\n   */\n  public async transferLocked(\n    target: string,\n    qty: number,\n    lockLength: number,\n    tags: TagInterface[] = [],\n  ): Promise<string> {\n    tags = [\n      ...(await this.cleanTags(tags)),\n      ...[\n        { name: 'Action', value: 'transferLocked' },\n        {\n          name: 'Message',\n          value: `Transfer locked to ${target} of ${Utils.formatNumber(qty)} for ${Utils.formatNumber(\n            lockLength,\n          )} blocks.`,\n        },\n        { name: 'Community-ID', value: this.communityContract },\n        { name: 'Service', value: 'CommunityXYZ' },\n      ],\n    ];\n\n    return this.interact({ function: 'transferLocked', target, qty, lockLength }, tags);\n  }\n\n  /**\n   * Lock your balances in a vault to earn voting weight.\n   * @param qty - Positive integer for the quantity to lock\n   * @param lockLength - Length of the lock, in blocks\n   * @param tags - optional: tags to be added to this transaction\n   * @returns The transaction ID for this action\n   */\n  public async lockBalance(qty: number, lockLength: number, tags: TagInterface[] = []): Promise<string> {\n    tags = [\n      ...(await this.cleanTags(tags)),\n      ...[\n        { name: 'Action', value: 'lock' },\n        {\n          name: 'Message',\n          value: `Locked ${Utils.formatNumber(qty)} for ${Utils.formatNumber(lockLength)} blocks (${Utils.formatBlocks(\n            lockLength,\n          )}).`,\n        },\n        { name: 'Community-ID', value: this.communityContract },\n        { name: 'Service', value: 'CommunityXYZ' },\n      ],\n    ];\n\n    return this.interact({ function: 'lock', qty, lockLength }, tags);\n  }\n\n  /**\n   * Unlock all your locked balances that are over the lock period.\n   * @param tags - optional: tags to be added to this transaction\n   * @returns The transaction ID for this action\n   */\n  public async unlockVault(tags: TagInterface[] = []): Promise<string> {\n    tags = [\n      ...(await this.cleanTags(tags)),\n      ...[\n        { name: 'Action', value: 'unlock' },\n        { name: 'Message', value: `Unlocked vaults.` },\n        { name: 'Community-ID', value: this.communityContract },\n        { name: 'Service', value: 'CommunityXYZ' },\n      ],\n    ];\n    return this.interact({ function: 'unlock' }, tags);\n  }\n\n  /**\n   * Increase the lock time (in blocks) of a vault.\n   * @param vaultId - The vault index position to increase\n   * @param lockLength - Length of the lock, in blocks\n   * @param tags - optional: tags to be added to this transaction\n   * @returns The transaction ID for this action\n   */\n  public async increaseVault(vaultId: number, lockLength: number, tags: TagInterface[] = []): Promise<string> {\n    tags = [\n      ...(await this.cleanTags(tags)),\n      ...[\n        { name: 'Action', value: 'increase' },\n        {\n          name: 'Message',\n          value: `Increased vault ID ${vaultId} for ${lockLength} blocks (${Utils.formatBlocks(lockLength)}).`,\n        },\n        { name: 'Community-ID', value: this.communityContract },\n        { name: 'Service', value: 'CommunityXYZ' },\n      ],\n    ];\n    return this.interact({ function: 'increaseVault', id: vaultId, lockLength }, tags);\n  }\n\n  /**\n   * Create a new vote\n   * @param params VoteInterface without the \"function\"\n   * @param tags - optional: tags to be added to this transaction\n   * @returns The transaction ID for this action\n   */\n  public async proposeVote(params: VoteInterface, tags: TagInterface[] = []): Promise<string> {\n    const pCopy: VoteInterface = JSON.parse(JSON.stringify(params));\n    console.log(pCopy);\n\n    if (pCopy.type === 'set') {\n      if (\n        pCopy.key === 'quorum' ||\n        pCopy.key === 'support' ||\n        pCopy.key === 'lockMinLength' ||\n        pCopy.key === 'lockMaxLength'\n      ) {\n        pCopy.value = +pCopy.value;\n      }\n\n      if (pCopy.key === 'quorum' || pCopy.key === 'support') {\n        if (pCopy.value > 0 && pCopy.value < 100) {\n          pCopy.value = pCopy.value / 100;\n        } else if (pCopy.value <= 0 || pCopy.value >= 100) {\n          throw new Error('Invalid value.');\n        }\n      }\n\n      if (\n        pCopy.key === 'lockMinLength' &&\n        (pCopy.value < 1 || pCopy.value > this.state.settings.get('lockMaxLength'))\n      ) {\n        throw new Error('Invalid minimum lock length.');\n      }\n      if (\n        pCopy.key === 'lockMaxLength' &&\n        (pCopy.value < 1 || pCopy.value < this.state.settings.get('lockMinLength'))\n      ) {\n        throw new Error('Invalid maximum lock length.');\n      }\n    }\n\n    const input: InputInterface = { ...pCopy, function: 'propose' };\n\n    tags = [\n      ...(await this.cleanTags(tags)),\n      ...[\n        { name: 'Action', value: 'propose' },\n        {\n          name: 'Message',\n          value: `Proposed ${pCopy.type === 'indicative' || pCopy.key === 'other' ? 'an' : 'a'} ${\n            pCopy.key || pCopy.type\n          } vote, value: ${pCopy.value}.`,\n        },\n        { name: 'Community-ID', value: this.communityContract },\n        { name: 'Service', value: 'CommunityXYZ' },\n      ],\n    ];\n    return this.interact(input, tags);\n  }\n\n  /**\n   * Cast a vote on an existing, and active, vote proposal.\n   * @param id - The vote ID, this is the index of the vote in votes\n   * @param cast - Cast your vote with 'yay' (for yes) or 'nay' (for no)\n   * @param tags - optional: tags to be added to this transaction\n   * @returns The transaction ID for this action\n   */\n  public async vote(id: number, cast: 'yay' | 'nay', tags: TagInterface[] = []): Promise<string> {\n    tags = [\n      ...(await this.cleanTags(tags)),\n      ...[\n        { name: 'Action', value: 'vote' },\n        { name: 'Message', value: `Voted on vote ID ${id}: ${cast}.` },\n        { name: 'Community-ID', value: this.communityContract },\n        { name: 'Service', value: 'CommunityXYZ' },\n      ],\n    ];\n    return this.interact({ function: 'vote', id, cast }, tags);\n  }\n\n  /**\n   * Finalize a vote, to run the desired vote details if approved, or reject it and close.\n   * @param id - The vote ID, this is the index of the vote in votes\n   * @param tags - optional: tags to be added to this transaction\n   * @returns The transaction ID for this action\n   */\n  public async finalize(id: number, tags: TagInterface[] = []): Promise<string> {\n    tags = [\n      ...(await this.cleanTags(tags)),\n      ...[\n        { name: 'Action', value: 'finalize' },\n        { name: 'Message', value: `Finalize completed votes.` },\n        { name: 'Community-ID', value: this.communityContract },\n        { name: 'Service', value: 'CommunityXYZ' },\n      ],\n    ];\n    return this.interact({ function: 'finalize', id }, tags);\n  }\n\n  /**\n   * Charge a fee for each Community's interactions.\n   * @param fee - which fee to charge\n   */\n  private async chargeFee(fee: number = this.txFee): Promise<{ target: string; winstonQty: string }> {\n    const balance = await this.arweave.wallets.getBalance(this.walletAddress);\n\n    if (+balance < +fee) {\n      throw new Error('Not enough balance.');\n    }\n\n    let state: StateInterface;\n    try {\n      state = (await axios(`${this.cacheServer}contract/${this.mainContract}`)).data;\n    } catch (e) {\n      state = await readContract(this.arweave, this.mainContract);\n    }\n\n    const target = await this.selectWeightedHolder(state.balances, state.vault);\n    if (target === this.walletAddress) {\n      return {\n        target: '',\n        winstonQty: '0',\n      };\n    }\n\n    return {\n      target,\n      winstonQty: this.arweave.ar.arToWinston(fee.toString()),\n    };\n  }\n\n  /**\n   * Function used to check if the user is already logged in\n   */\n  private async checkWallet(): Promise<void> {\n    if (!this.wallet && !this.isWalletConnect) {\n      throw new Error(\n        'You first need to set the user wallet, you can do this while on new Community(..., wallet) or using setWallet(wallet).',\n      );\n    }\n  }\n\n  /**\n   * Stringify and remove tags that are defined by CommunityJS\n   * @returns An array of the TagInterface object `{name: string, value: string}`\n   */\n  private async cleanTags(tags: TagInterface[]): Promise<TagInterface[]> {\n    if (!tags || !tags.length) {\n      return [];\n    }\n\n    const blacklist: string[] = ['action', 'message', 'community-id', 'service', 'type'];\n    const res: TagInterface[] = [];\n\n    for (const tag of tags) {\n      if (!tag.name || !tag.value) continue;\n\n      if (!blacklist.includes(tag.name.toLowerCase())) {\n        res.push({\n          name: tag.name.toString(),\n          value: tag.value.toString(),\n        });\n      }\n    }\n\n    return res;\n  }\n\n  /**\n   * Updates the current state used for a Community instance\n   * @param recall Auto recall this function each cacheRefreshInterval ms\n   */\n  private async update(recall = false): Promise<StateInterface> {\n    if (!this.communityContract.length) {\n      setTimeout(() => this.update(), this.cacheRefreshInterval);\n      return;\n    }\n\n    if (this.stateCallInProgress) {\n      const getLastState = async (): Promise<StateInterface> => {\n        if (this.stateCallInProgress) {\n          return new Promise((resolve) => setTimeout(() => resolve(getLastState()), 1000));\n        }\n\n        return this.state;\n      };\n      return getLastState();\n    }\n\n    this.stateCallInProgress = true;\n\n    let state: StateInterface;\n    try {\n      state = (await axios(`${this.cacheServer}contract/${this.communityContract}`)).data;\n    } catch (e) {\n      state = await readContract(this.arweave, this.communityContract);\n    }\n\n    state.settings = new Map(state.settings);\n    this.state = state;\n\n    this.stateCallInProgress = false;\n\n    if (recall) {\n      setTimeout(() => this.update(true), this.cacheRefreshInterval);\n    }\n    return this.state;\n  }\n\n  /**\n   * The most important function, it writes to the contract.\n   * @param input - InputInterface\n   * @param tags - Array of tags as an object with name and value as strings\n   * @param fee - Transaction fee\n   */\n  private async interact(\n    input: InputInterface,\n    tags: { name: string; value: string }[],\n    fee: number = this.txFee,\n  ): Promise<string> {\n    const { target, winstonQty } = await this.chargeFee(fee);\n\n    tags.push({ name: 'Type', value: 'ArweaveActivity' });\n\n    const res = await interactWriteDryRun(\n      this.arweave,\n      this.wallet || 'use_wallet',\n      this.communityContract,\n      input,\n      tags,\n      target,\n      winstonQty,\n    );\n    if (res.type === 'error') {\n      //  || res.type === 'exception'\n      throw new Error(res.result);\n    }\n\n    return interactWrite(\n      this.arweave,\n      this.wallet || 'use_wallet',\n      this.communityContract,\n      input,\n      tags,\n      target,\n      winstonQty,\n    );\n  }\n\n  /**\n   * Create events to handle the wallet connect feature\n   */\n  private events() {\n    const win: any =\n      typeof window !== 'undefined'\n        ? window\n        : {\n            removeEventListener: (evName: string) => {},\n            addEventListener: (evName: string, callback: (e: any) => {}) => {},\n          };\n\n    async function walletConnect() {\n      this.walletAddress = await this.arweave.wallets.getAddress();\n      this.isWalletConnect = true;\n    }\n    async function walletSwitch(e: any) {\n      this.walletAddress = await e.detail.address;\n      this.isWalletConnect = true;\n    }\n\n    win.removeEventListener('arweaveWalletLoaded', () => walletConnect());\n    win.removeEventListener('walletSwitch', (e) => walletSwitch(e));\n    win.addEventListener('arweaveWalletLoaded', () => walletConnect());\n    win.addEventListener('walletSwitch', (e) => walletSwitch(e));\n  }\n}\n"],"names":["exports","cacheServer","contractSrc","mainContract","txFeeUsd","createFeeUsd","createFee","txFee","arweave","wallet","walletAddress","dummyWallet","isWalletConnect","communityContract","state","firstCall","cacheRefreshInterval","stateCallInProgress","warnAfter","updatedFees","constructor","this","wallets","jwkToAddress","then","addy","catch","console","log","getFees","events","getMainContractId","getContractSourceId","getCommunityContract","getState","cached","length","Error","update","setWallet","setState","name","ticker","balances","quorum","support","voteLength","lockMinLength","lockMaxLength","vault","votes","roles","extraSettings","checkWallet","trim","utils_1","trimObj","Object","keys","bal","isNaN","Number","isInteger","key","k","balance","settings","i","j","s","push","Map","setContractSourceId","id","isTxId","create","tags","target","winstonQty","chargeFee","toSubmit","Array","from","cleanTags","value","communityID","smartweave_1","JSON","stringify","getCreateCost","inAr","options","Promise","resolve","setTimeout","res","ar","arToWinston","toString","winstonToAr","getActionCost","setCommunityTx","txId","e","get","params","function","generate","getBalance","getUnlockedBalance","getVaultBalance","getRole","role","selectWeightedHolder","totalTokens","vaultBalance","map","a","reduce","b","weighted","sum","r","Math","random","price","redstone_api_1","getPrice","createdAt","timestamp","arPrice","Date","getTime","warn","toFixed","transfer","qty","formatNumber","interact","transferLocked","lockLength","lockBalance","formatBlocks","unlockVault","increaseVault","vaultId","proposeVote","pCopy","parse","type","input","vote","cast","finalize","fee","axios_1","data","blacklist","tag","includes","toLowerCase","recall","getLastState","async","result","win","window","removeEventListener","evName","addEventListener","callback","walletConnect","getAddress","walletSwitch","detail","address"],"mappings":"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"}